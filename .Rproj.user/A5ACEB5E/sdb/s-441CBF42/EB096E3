{
    "collab_server" : "",
    "contents" : "\nmulticore_operate <- function(indexsStack, i_opera, series_cores = 1) {    \n  \n  xaxis <- julian(as.Date(getZ(indexsStack)))\n  \n  # Each function needs a vector containing time series data in per pixel\n  \n  # Calculating mean value --------------------------------------------------\n  .stack_mean <- function(indivVector){\n    rline <- mean(x = indivVector, na.rm = TRUE)\n    return(rline)\n  }\n  \n  # Fitting a trigonometric model ------------------------------------------\n  .fit_tri <- function(indivVector){\n    rline<-list(NA,NA,NA,NA,NA)\n    if (sum(indivVector, na.rm = TRUE) != 0) {\n      yaxis <- indivVector\n      fdata <- data.frame(xaxis, indivVector)\n      fresult = lm(yaxis ~ xaxis + I(cospi((2/365.256363004)*xaxis)) + I(sinpi((2/365.256363004)*xaxis)), data = fdata)\n      b0 <- summary(fresult)$coefficients[1]\n      b1 <- summary(fresult)$coefficients[2]\n      b2 <- summary(fresult)$coefficients[3]\n      b3 <- summary(fresult)$coefficients[4]\n      r2 <- summary(fresult)$r.squared\n      rline <- c(b0, b1, b2, b3, r2)\n    }\n    return(rline)\n  }\n  \n  # Fitting a trigonometric model and enhance some parameters---------------\n  .fit_tri_en <- function(indivVector){\n    rline<-list(NA,NA,NA,NA,NA)\n    if (sum(indivVector, na.rm = TRUE) != 0) {\n      yaxis <- indivVector\n      fdata <- data.frame(xaxis, indivVector)\n      fresult = lm(yaxis ~ xaxis + I(cospi((2/365.256363004)*xaxis)) + I(sinpi((2/365.256363004)*xaxis)), data = fdata)\n      b0 <- summary(fresult)$coefficients[1]\n      b1 <- summary(fresult)$coefficients[2]\n      b2 <- summary(fresult)$coefficients[3]\n      b3 <- summary(fresult)$coefficients[4]\n      r2 <- summary(fresult)$r.squared\n      rline <- c(b0, b1*b0, b2*b0, b3*b0, r2)\n    }\n    return(rline)\n  }\n  \n  # Fitting a 2 order polynomial model -------------------------------------\n  .fit_poly2 <- function(indivVector){\n    rline<-list(NA,NA,NA,NA)\n    if (sum(indivVector, na.rm = TRUE) != 0) {\n      yaxis <- indivVector\n      fdata <- data.frame(xaxis, indivVector)\n      fresult = lm(yaxis ~ xaxis + I(xaxis^2), data = fdata)\n      b0 <- summary(fresult)$coefficients[1]\n      b1 <- summary(fresult)$coefficients[2]\n      b2 <- summary(fresult)$coefficients[3]\n      r2 <- summary(fresult)$r.squared\n      rline <- c(b0, b1, b2, r2)\n    }\n    return(rline)\n  }\n  \n  # Fitting a 3 order polynomial model -------------------------------------\n  .fit_poly3 <- function(indivVector){\n    rline<-list(NA,NA,NA,NA,NA)\n    if (sum(indivVector, na.rm = TRUE) != 0) {\n      yaxis <- indivVector\n      fdata <- data.frame(xaxis, indivVector)\n      fresult = lm(yaxis ~ xaxis + I(xaxis^2) + I(xaxis^3), data = fdata)\n      b0 <- summary(fresult)$coefficients[1]\n      b1 <- summary(fresult)$coefficients[2]\n      b2 <- summary(fresult)$coefficients[3]\n      b3 <- summary(fresult)$coefficients[4]\n      r2 <- summary(fresult)$r.squared\n      rline <- c(b0, b1, b2, b3, r2)\n    }\n    return(rline)\n  }\n  \n  if(i_opera == 'stack_mean') {\n    core_fun <- .stack_mean\n    \n  } else if(i_opera == 'fit_tri') {\n    core_fun <- .fit_tri\n    \n  } else if(i_opera == 'fit_tri_en') {\n    core_fun <- .fit_tri_en\n    \n  } else if(i_opera == 'fit_poly2') {\n    core_fun <- .fit_poly2\n    \n  } else if(i_opera == 'fit_poly3') {\n    core_fun <- .fit_poly3\n    \n  } else {\n    stop(\"Unsupported operation\")\n    return()\n  }\n  \n  \n  \n  if(series_cores == 1) { # Normal calc\n    out <- calc(x=indexsStack, fun=core_fun, ...)\n    return(out)\n  } else {\n    \n    # Create blocks and run the function on that bloc\n    s <- blockSize(indexsStack, minblocks=series_cores)\n    blocs <- seq(1, s$n)\n    fun2X <- function(i) {\n      e <- extent(indexsStack, r1=s$row[i], r2=s$row[i]+s$nrows[i]-1)\n      Xb <- crop(indexsStack, e)\n      out <- calc(x=Xb, fun=core_fun)\n      return(out)\n    }\n    listOut <- mclapply(X=blocs, FUN=fun2X, mc.cores=series_cores)\n    listOut$fun <- max\n    resultBrick <- do.call(mosaic, listOut)\n    return(resultBrick)\n  }\n}",
    "created" : 1502852966210.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "934693742",
    "id" : "EB096E3",
    "lastKnownWriteTime" : 1504064311,
    "last_content_update" : 1504064311346,
    "path" : "~/XWorkSpace/qianshan/Program/LaTiP/multicore_operate.R",
    "project_path" : "multicore_operate.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}